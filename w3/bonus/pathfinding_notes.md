# Maze Notes

A* pathfinding for beginners. There are many articles that go over the method,
but none go over the true beginnings of the concept.

## Introduction: The Search Area

Let's assume we want to go from point A to point B in the picture here.

![alt text][fig1]

A is the green square, and B is the red, with a blue wall between them.
Each square is a potential location to move to. Once the path is found, the
person moves to the center of each square until they reach the end.

These center points are called nodes. Since the shape we split our grid into can
be anything, hexagons, triangles, etc. and the nodes can be placed anywhere
within this shape. But for this example, it is easiest to use / call these nodes
_squares_.

#### Starting the Search

Now that the search area has been simplified into a manageable number of nodes,
 we can start the search. Now we start at point A, check the nearby squares,
 and searching outward until we find our target.

Here is the general search in step form:
  1. Begin at 'A' and add it to an _open list_ of squares to be considered.
  This list contains squares that may fall on the path to the finish, but may be
  discarded.
  2. Look at all the reachable or walkable squares to the starting point,
  ignoring squares with walls, water, or other illegal terrain. Add these to the
  open list as well. For each of these squares, add 'A' as the parent square.
  3. Drop the starting square 'A' from your open list, and add it to a closed
  list of squares that you don't need to look at again for now.

At this point you should have something like below:

![alt text][fig2]

Each square has a grey pointer that shows its parent square.

Now we need to find the next square to go to. But how do we choose? By finding the square with the lowest __F score__.

#### Path Scoring

The key to determining the next square is to use the formula
> F = G + H

where:
  * G = movement cost to move from starting point A to the square
  * H = movement cost to move from that square to final destination. This is an
  estimate. This is often referred to the heuristic, which is a bit confusing.
  This is a guess, because other things can be in the way. There is one way to
  calc H in this tutorial, but there are plenty of other ways.

The path is generated by iterating over the open-list and scoring all the items,
then picking the one with the lowest F score. The easiest way to calculate G
cost is to take the G cost of its parent and then increment G by the per-unit
number.

> What happens when you have no movement cost? G = 0?

H can be estimated in a variety of ways. The one demoed here is the Manhattan
method. This involves moving only orthogonally to reach the target and
multiplying by the cost of movement, ignoring all obstacles. (This would probably work really well for the maze-solver since we'll have an array as a searchable area)

Computing the scores around the start will get you the following:

![alt text][fig3]

The square directly to the right has the lowest F score (40). So choose that and
  4. Move it to the closed list.
  5. Check all adjacent squares, ignoring unwalkable squares.
  6. If an adjacent square is already on the open list, check to see if it is
  a better fit (lower G cost). _not important for our purposes_

In the case of ties, usually pick the last one added to the list, but can be
random.

Repeat this process until the target gets added to the open-list. Then set the
path by going backwards and setting each location to a '#' and then the next
location is the parent of the current square.

You should end with a path to your target!

![alt text][fig4]

[fig1]: http://www.policyalmanac.org/games/aStarT1.jpg
[fig2]: http://www.policyalmanac.org/games/aStarT2.jpg
[fig3]: http://www.policyalmanac.org/games/aStarT3.jpg
[fig4]: http://www.policyalmanac.org/games/aStarT7.jpg
